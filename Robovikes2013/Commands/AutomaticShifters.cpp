// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "AutomaticShifters.h"

namespace
{

double maxCurrent(double a, double b, double c, double d) {
	if(a > b && a > c && a > d) return a;
	if(b > a && b > c && b > d) return b;
	if(c > a && c > b && c > d) return c;
	return d;
}

}

void AutomaticShifters::calcCurrentSlope() {
	//take current of motor with highest current:
	double newCurrent = maxCurrent(Robot::chassis->frontLeft->GetOutputCurrent(),
				                   Robot::chassis->frontRight->GetOutputCurrent(),
				                   Robot::chassis->rearLeft->GetOutputCurrent(),
				                   Robot::chassis->rearRight->GetOutputCurrent()); 
	//record slope
	slope = (newCurrent - prevCurrent)/k10ms;
		
	prevCurrent = newCurrent;
	return;
}
void AutomaticShifters::gGetCurrentSlope(void* param) {
	//global function for creating instance of AutomaticShifters
	AutomaticShifters* this_ = static_cast<AutomaticShifters*>(param);
	this_->calcCurrentSlope();
	return;
}
AutomaticShifters::AutomaticShifters()
:slope(0), Sol(0), shiftCount(0), prevCurrent(0), currentSampler(gGetCurrentSlope, this)
{
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::shifter);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
// Called just before this Command runs the first time
void AutomaticShifters::Initialize() {
	currentSampler.StartPeriodic(k10ms); 
}
// Called repeatedly when this Command is scheduled to run
void AutomaticShifters::Execute() {
	gGetCurrentSlope(&slope);
	const double tooLow = 1000; //current at which shift to high
	const double tooHigh = 1000; //current at which shift to low
	if(slope < tooLow) //if current is decreasing quickly
	{
		//shift to high:
		if(Robot::shifter->shifter->Get() == DoubleSolenoid::kReverse) ++shiftCount;
		Robot::shifter->shifter->Set(DoubleSolenoid::kForward); //preCur average 17, slope 2000-3000
	}
	if(slope > tooHigh) //if current is increasing quickly
	{
		//shift to low:
		if(Robot::shifter->shifter->Get() == DoubleSolenoid::kForward) ++shiftCount;
		Robot::shifter->shifter->Set(DoubleSolenoid::kReverse); //prevCur average 10, slope 1000-2000
	}
	SmartDashboard::PutNumber("Slope", slope);
	SmartDashboard::PutNumber("prevCur", prevCurrent);
	SmartDashboard::PutNumber("shiftCount", shiftCount);
	if(Robot::shifter->shifter->Get() == DoubleSolenoid::kForward) Sol = 1; //1 = low
	if(Robot::shifter->shifter->Get() == DoubleSolenoid::kReverse) Sol = 2; //2 = high
	SmartDashboard::PutNumber("Solenoid", Sol);
}
// Make this return true when this Command no longer needs to run execute()
bool AutomaticShifters::IsFinished() {
	return false;
}
// Called once after isFinished returns true
void AutomaticShifters::End() {
	
}
// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutomaticShifters::Interrupted() {
}
